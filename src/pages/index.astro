---
import BaseLayout from '../layouts/BaseLayout.astro';
import Nav from '../components/Nav.astro';
import Hero from '../components/Hero.astro';
import Screenshot from '../components/Screenshot.astro';
import Features from '../components/Features.astro';
import SecondScreenshot from '../components/SecondScreenshot.astro';
import TrustStrip from '../components/TrustStrip.astro';
import DownloadCTA from '../components/DownloadCTA.astro';
import Footer from '../components/Footer.astro';
---

<BaseLayout>
  <Nav />

  <main id="main-content">
    <!-- Hero -->
    <Hero />

    <!-- Hero Screenshot -->
    <Screenshot
      src="/screenshots/hero-diff.png"
      alt="DotEdit side-by-side diff view comparing staging and production environment files"
      priority
    />

    <!-- Features Strip -->
    <Features />

    <!-- Second Screenshot + Caption -->
    <SecondScreenshot />

    <!-- Trust Strip -->
    <TrustStrip />

    <!-- Download CTA -->
    <DownloadCTA />
  </main>

  <!-- Footer -->
  <Footer />

  <!-- Custom cursor element -->
  <div class="cursor-dot" id="cursor-dot" aria-hidden="true"></div>

  <!-- Micro-interactions: scroll reveal, parallax, cursor, shadow tracking -->
  <script>
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
    const isDesktop = window.innerWidth >= 1024;

    // --- Scroll Reveal (IntersectionObserver) ---
    // Add js-ready so CSS gates reveal animations (content visible without JS)
    document.body.classList.add('js-ready');

    if (!prefersReduced) {
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add('revealed');
              observer.unobserve(entry.target);
            }
          });
        },
        { threshold: 0.15 }
      );
      document.querySelectorAll('.reveal').forEach((el) => observer.observe(el));
    } else {
      document.querySelectorAll('.reveal').forEach((el) => el.classList.add('revealed'));
    }

    // --- Custom Cursor ---
    if (!prefersReduced && !isCoarsePointer && isDesktop) {
      document.body.classList.add('custom-cursor-enabled');
      const cursor = document.getElementById('cursor-dot') as HTMLElement;
      let mouseX = 0, mouseY = 0;
      let cursorX = 0, cursorY = 0;

      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      }, { passive: true });

      // Hover detection for interactive elements
      const interactiveSelectors = 'a, button, [role="button"], input, textarea, select, [tabindex]';

      document.addEventListener('mouseover', (e) => {
        const target = e.target as HTMLElement;
        if (target.closest(interactiveSelectors)) {
          cursor?.classList.add('hovering');
        }
      });

      document.addEventListener('mouseout', (e) => {
        const target = e.target as HTMLElement;
        if (target.closest(interactiveSelectors)) {
          cursor?.classList.remove('hovering');
        }
      });

      // Smooth cursor movement via lerp at 60fps
      function animateCursor() {
        cursorX += (mouseX - cursorX) * 0.15;
        cursorY += (mouseY - cursorY) * 0.15;
        if (cursor) {
          cursor.style.transform = `translate(${cursorX - 6}px, ${cursorY - 6}px)`;
        }
        requestAnimationFrame(animateCursor);
      }
      animateCursor();
    }

    // --- Screenshot Parallax + Shadow Mouse Tracking ---
    if (!prefersReduced) {
      const parallaxElements = document.querySelectorAll('[data-parallax]');

      // Parallax on scroll
      let ticking = false;
      window.addEventListener('scroll', () => {
        if (!ticking) {
          requestAnimationFrame(() => {
            const scrollY = window.scrollY;
            parallaxElements.forEach((el) => {
              const element = el as HTMLElement;
              const rect = element.getBoundingClientRect();
              const center = rect.top + rect.height / 2;
              const viewportCenter = window.innerHeight / 2;
              const offset = (center - viewportCenter) * 0.15;
              element.style.transform = `translateY(${offset}px)`;
            });
            ticking = false;
          });
          ticking = true;
        }
      }, { passive: true });

      // Shadow tracking on mouse move removed â€” transparent screenshots don't use box-shadow
    }
  </script>
</BaseLayout>
